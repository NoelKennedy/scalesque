<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>

<#@ output extension=".cs" #>
using System;

namespace Scalesque {

	//Warning: This file was generated by a T4 template.  Any manual changes you make maybe overwritten when the templating code activates.

	<#
	var typesToGenFor = new[]{"Option"};
	foreach(var genType in typesToGenFor){
	#>
public static class <#=genType#>ApplicativeFunctors {
	<#
	
		Func<IEnumerable<string>, string, string> seperate =(list, seperator) => list.Aggregate("", (acc, t) => acc + seperator + t).Trim(seperator.ToCharArray());
		for(int arity=2;arity<=8;arity++){
			var inputGenTypes = seperate(Enumerable.Range(2, arity -1).Select(x => String.Format("{0}<T{1}> t{1}", genType, x)), ",");
			var methodGenerics = seperate(Enumerable.Range(1, arity).Select(x => String.Format("T{0}",x)),",");
			var leftApplicativeCalls = seperate(Enumerable.Range(2, arity -1).Reverse().Select(x => String.Format("t{0}.Applicative",x)),"(");
			var rightApplicativeCalls = seperate(Enumerable.Range(1, arity -1).Select(x => ")"), "");
			

			#>
	/// <summary>
		/// Implements an applicative functor on <#=genType#>
		/// </summary>
		public static <#=genType#><TResult> ApplicativeFunctor<<#=methodGenerics#>,TResult>(this <#=genType#><T1> t1, <#=inputGenTypes#>, Func<<#=methodGenerics#>,TResult> f) {
			return <#=leftApplicativeCalls#>(t1.Map(f.Curry()<#=rightApplicativeCalls#>);
		}

	<#

		}

	#>
}
<# } #>
}